{"version":3,"file":"barcode-detector.modern.js","sources":["../src/image-data.ts","../src/BarcodeDetectorZXing.ts"],"sourcesContent":["\nfunction imageDataFromCanvas(image : CanvasImageSource, width : number, height : number) : ImageData {\n  const canvas = document.createElement(\"canvas\");\n  const canvasCtx = canvas.getContext(\"2d\");\n\n  canvas.width = width;\n  canvas.height = height;\n\n  canvasCtx.drawImage(image, 0, 0, width, height);\n\n  return canvasCtx.getImageData(0, 0, width, height);\n}\n\nasync function imageDataFromBlob(blob : Blob) : Promise<ImageData> {\n  // turn blob into an img element and pass back to imageDataFrom\n  const url = URL.createObjectURL(blob)\n\n  const image = new Image()\n  image.src = url\n\n  await new Promise((resolve, reject) => {\n    image.onload = resolve\n    image.onerror = reject\n  })\n\n  URL.revokeObjectURL(url)\n\n  return imageDataFrom(image)\n}\n\nexport async function imageDataFrom(image : ImageBitmapSource) : Promise<ImageData> {\n  // spec quoted from:\n  // https://wicg.github.io/shape-detection-api/#image-sources-for-detection\n\n  // [TODO]\n  // If any ImageBitmapSource have an effective script origin (origin) which is \n  // not the same as the Document’s effective script origin, then reject the \n  // Promise with a new DOMException whose name is SecurityError.\n\n  if (image instanceof HTMLImageElement) {\n\n    // [TODO]\n    // When an ImageBitmapSource object represents an HTMLImageElement, the \n    // element’s image must be used as the source image. Specifically, when an \n    // ImageBitmapSource object represents an animated image in an \n    // HTMLImageElement, the user agent must use the default image of the \n    // animation (the one that the format defines is to be used when animation \n    // is not supported or is disabled), or, if there is no such image, the \n    // first frame of the animation.\n\n    // [SPEC]\n    // If the ImageBitmapSource is an HTMLImageElement object that is in the \n    // Broken (HTML Standard §img-error) state, then reject the Promise with a \n    // new DOMException whose name is InvalidStateError, and abort any further \n    // steps.\n    // [SPEC]\n    // If the ImageBitmapSource is an HTMLImageElement object that is not fully \n    // decodable then reject the Promise with a new DOMException whose name is \n    // InvalidStateError, and abort any further steps\n    try {\n      image.decode()\n    } catch (_) {\n      throw new DOMException(\"HTMLImageElement is not decodable\", \"InvalidStateError\")\n    }\n\n    return imageDataFromCanvas(image, image.naturalWidth, image.naturalHeight)\n\n  } else if (image instanceof SVGImageElement) {\n\n    // TODO width/height is a little bit arbitrary\n    return imageDataFromCanvas(image, 640, 480)\n\n  } else if (image instanceof HTMLVideoElement) {\n\n    // [SPEC]\n    // If the ImageBitmapSource is an HTMLVideoElement object whose readyState \n    // attribute is either HAVE_NOTHING or HAVE_METADATA then reject the Promise \n    // with a new DOMException whose name is InvalidStateError, and abort any \n    // further steps.\n    const HAVE_NOTHING = 0, HAVE_METADATA = 1;\n    if (image.readyState === HAVE_NOTHING || image.readyState === HAVE_METADATA) {\n      throw new DOMException(\"\", \"InvalidStateError\")\n    }\n\n    // [SPEC]\n    // When an ImageBitmapSource object represents an HTMLVideoElement, then \n    // the frame at the current playback position when the method with the \n    // argument is invoked must be used as the source image when processing the \n    // image, and the source image’s dimensions must be the intrinsic dimensions \n    // of the media resource (i.e. after any aspect-ratio correction has been applied).\n    return imageDataFromCanvas(image, image.videoWidth, image.videoHeight)\n\n  } else if (image instanceof HTMLCanvasElement) {\n\n    // [TODO]\n    // When an ImageBitmapSource object represents an HTMLCanvasElement, the \n    // element’s bitmap must be used as the source image.\n    \n    // [TODO]\n    // If the ImageBitmapSource argument is an HTMLCanvasElement whose bitmap’s \n    // origin-clean (HTML Standard §concept-canvas-origin-clean) flag is false, \n    // then reject the Promise with a new DOMException whose name is \n    // SecurityError, and abort any further steps.\n\n    const canvasCtx = image.getContext(\"2d\")\n    return canvasCtx.getImageData(0, 0, image.width, image.height)\n\n  } else if ('ImageBitmap' in window && image instanceof ImageBitmap) {\n\n    return imageDataFromCanvas(image, image.width, image.height)\n\n  // Can't perform instanceof check when OffscreenCanvas not supported. Thus\n  // need to feature detect first.\n  } else if ('OffscreenCanvas' in window && image instanceof OffscreenCanvas) {\n\n    const canvasCtx = image.getContext(\"2d\")\n    return canvasCtx.getImageData(0, 0, image.width, image.height)\n\n  } else if (image instanceof Blob) {\n\n    return imageDataFromBlob(image)\n\n  } else if (image instanceof ImageData) {\n\n    return image\n\n  } else {\n    // TODO TypeError?\n  }\n}","// spec: https://wicg.github.io/shape-detection-api/#barcode-detection-api  \n\nimport {BarcodeDetectorOptions, BarcodeFormat, DetectedBarcode} from \"./basic-types\"\nimport {imageDataFrom} from \"./image-data\"\nimport * as ZXing from \"@zxing/library\"\n\nconst mapFormat = new Map<BarcodeFormat, ZXing.BarcodeFormat>([\n\n    [\"aztec\", ZXing.BarcodeFormat.AZTEC],\n    // [ \"codabar\", ZXing.BarcodeFormat.CODABAR ],\n    [\"code_39\", ZXing.BarcodeFormat.CODE_39],\n    // [ \"code_93\", ZXing.BarcodeFormat.CODE_93 ],\n    [\"code_128\", ZXing.BarcodeFormat.CODE_128],\n    [\"data_matrix\", ZXing.BarcodeFormat.DATA_MATRIX],\n    [\"ean_8\", ZXing.BarcodeFormat.EAN_8],\n    [\"ean_13\", ZXing.BarcodeFormat.EAN_13],\n    [\"itf\", ZXing.BarcodeFormat.ITF],\n    [\"pdf417\", ZXing.BarcodeFormat.PDF_417],\n    [\"qr_code\", ZXing.BarcodeFormat.QR_CODE],\n    [\"upc_a\", ZXing.BarcodeFormat.UPC_A],\n    [\"upc_e\", ZXing.BarcodeFormat.UPC_E]\n\n])\n\nconst mapFormatInv = new Map<ZXing.BarcodeFormat, BarcodeFormat>(\n    Array.from(mapFormat).map(([key, val]) => [val, key])\n)\n\nconst allSupportedFormats: BarcodeFormat[] = Array.from(mapFormat.keys())\n\nconst mapResult = (result: ZXing.Result): DetectedBarcode => {\n    const format = mapFormatInv.get(result.getBarcodeFormat())\n    const rawValue = result.getText()\n\n    const cornerPoints = Object.freeze(\n        result\n            .getResultPoints()\n            .map(point => ({x: point.getX(), y: point.getY()}))\n    )\n\n    const pointsX = cornerPoints.map(point => point.x);\n    const pointsY = cornerPoints.map(point => point.y)\n    const x_min = Math.min(...pointsX)\n    const x_max = Math.max(...pointsX)\n    const y_min = Math.min(...pointsY)\n    const y_max = Math.max(...pointsY)\n\n    const boundingBox = DOMRectReadOnly.fromRect({\n        x: x_min,\n        y: y_min,\n        width: x_max - x_min,\n        height: y_max - y_min\n    })\n\n    return {format, rawValue, cornerPoints, boundingBox}\n}\n\nexport default class BarcodeDetector {\n\n    reader: ZXing.MultiFormatReader\n\n    constructor(barcodeDetectorOptions?: BarcodeDetectorOptions) {\n        // SPEC: A series of BarcodeFormats to search for in the subsequent detect() calls. If not present then the UA SHOULD\n        // search for all supported formats.\n        const formats = barcodeDetectorOptions?.formats ?? allSupportedFormats\n\n        // SPEC: If barcodeDetectorOptions.formats is present and empty, then throw a new TypeError.\n        if (formats.length === 0) {\n            throw new TypeError(\"\") // TODO pick message\n        }\n\n        // SPEC: If barcodeDetectorOptions.formats is present and contains unknown, then throw a new TypeError.\n        if (formats.includes(\"unknown\")) {\n            throw new TypeError(\"\") // TODO pick message\n        }\n\n        const hints = new Map([\n            [ZXing.DecodeHintType.POSSIBLE_FORMATS, formats.map(format => mapFormat.get(format))]\n        ])\n\n        this.reader = new ZXing.MultiFormatReader()\n        this.reader.setHints(hints)\n    }\n\n    static async getSupportedFormats(): Promise<BarcodeFormat[]> {\n        return allSupportedFormats\n    }\n\n    // INVESTIGATE:\n    // * native api on Mac Chrome gives \"Source not supported\" for Blob\n    // * only two corner points for code_39\n    async detect(image: ImageBitmapSource): Promise<DetectedBarcode[]> {\n        // TODO: [SPEC]\n        // Note that if the ImageBitmapSource is an object with either a horizontal dimension or a vertical dimension equal\n        // to zero, then the Promise will be simply resolved with an empty sequence of detected objects.\n\n        const imageData = await imageDataFrom(image)\n        const canvas = document.createElement(\"canvas\");\n        const canvasCtx = canvas.getContext(\"2d\");\n        canvas.width = imageData.width;\n        canvas.height = imageData.height;\n        canvasCtx.putImageData(imageData, 0, 0);\n\n        try {\n            const luminanceSource = new ZXing.HTMLCanvasElementLuminanceSource(canvas);\n            const binaryBitmap = new ZXing.BinaryBitmap(new ZXing.HybridBinarizer(luminanceSource));\n            const result = this.reader.decode(binaryBitmap);\n\n            return [mapResult(result)]\n        } catch (error) {\n            console.error(error);\n\n            return []\n        }\n    }\n}"],"names":["imageDataFromCanvas","image","width","height","canvas","document","createElement","canvasCtx","getContext","drawImage","getImageData","imageDataFrom","HTMLImageElement","decode","_","DOMException","naturalWidth","naturalHeight","SVGImageElement","HTMLVideoElement","HAVE_METADATA","readyState","videoWidth","videoHeight","HTMLCanvasElement","window","ImageBitmap","OffscreenCanvas","Blob","async","blob","url","URL","createObjectURL","Image","src","Promise","resolve","reject","onload","onerror","revokeObjectURL","imageDataFromBlob","ImageData","mapFormat","Map","ZXing","BarcodeFormat","AZTEC","CODE_39","CODE_128","DATA_MATRIX","EAN_8","EAN_13","ITF","PDF_417","QR_CODE","UPC_A","UPC_E","mapFormatInv","Array","from","map","key","val","allSupportedFormats","keys","mapResult","result","format","get","getBarcodeFormat","rawValue","getText","cornerPoints","Object","freeze","getResultPoints","point","x","getX","y","getY","pointsX","pointsY","x_min","Math","min","x_max","max","y_min","y_max","boundingBox","DOMRectReadOnly","fromRect","constructor","barcodeDetectorOptions","reader","formats","length","TypeError","includes","hints","DecodeHintType","POSSIBLE_FORMATS","this","MultiFormatReader","setHints","[object Object]","imageData","putImageData","luminanceSource","HTMLCanvasElementLuminanceSource","binaryBitmap","BinaryBitmap","HybridBinarizer","error","console"],"mappings":"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"}